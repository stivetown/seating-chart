{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { generateGroupSuggestions, calculateGroupStats } from '../utils/matching';\nimport { parseCSVToMembers } from '../utils/csvParser';\nexport function useMembers() {\n  _s();\n  const [members, setMembers] = useState([]);\n  const [groups, setGroups] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Load real CSV data\n  useEffect(() => {\n    loadCSVData();\n  }, []);\n  const loadCSVData = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // Load the CSV file\n      const response = await fetch('/HS_Import spreadsheet - Members.csv');\n      if (!response.ok) {\n        throw new Error('Failed to load CSV file');\n      }\n      const csvText = await response.text();\n      const parsedMembers = parseCSVToMembers(csvText);\n      console.log(`Loaded ${parsedMembers.length} members from CSV`);\n\n      // Set members\n      setMembers(parsedMembers);\n\n      // Create groups from existing group assignments\n      const groupMap = new Map();\n      parsedMembers.forEach(member => {\n        if (member.groupId) {\n          if (!groupMap.has(member.groupId)) {\n            groupMap.set(member.groupId, []);\n          }\n          groupMap.get(member.groupId).push(member);\n        }\n      });\n\n      // Convert to Group objects with proper stats\n      const createdGroups = [];\n      groupMap.forEach((members, groupId) => {\n        const groupNumber = groupId.replace('group_', '');\n        const groupStats = calculateGroupStats({\n          id: groupId,\n          name: `Group ${groupNumber}`,\n          members: members,\n          averageExperience: 0,\n          dominantPriceTier: '',\n          categories: [],\n          createdDate: '2024-01-01',\n          lastActivity: new Date().toISOString().split('T')[0]\n        });\n        createdGroups.push({\n          id: groupId,\n          name: `Group ${groupNumber}`,\n          members: members,\n          averageExperience: groupStats.averageExperience,\n          dominantPriceTier: groupStats.dominantPriceTier,\n          categories: groupStats.categories,\n          createdDate: '2024-01-01',\n          lastActivity: new Date().toISOString().split('T')[0]\n        });\n      });\n      setGroups(createdGroups);\n    } catch (err) {\n      console.error('Error loading CSV data:', err);\n      setError(err instanceof Error ? err.message : 'Failed to load member data');\n\n      // Fallback to a minimal mock dataset if CSV fails\n      setMembers([{\n        id: 'fallback_1',\n        name: 'CSV Loading Failed',\n        email: 'error@example.com',\n        experience: 'Intermediate',\n        priceTier: 'Mid-Range',\n        categories: ['Other'],\n        joinedDate: '2024-01-01',\n        lastActive: '2024-01-01'\n      }]);\n      setGroups([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n  const updateMemberGroup = (memberId, groupId) => {\n    setMembers(prevMembers => prevMembers.map(member => member.id === memberId ? {\n      ...member,\n      groupId\n    } : member));\n\n    // Update groups\n    setGroups(prevGroups => {\n      const newGroups = prevGroups.map(group => ({\n        ...group,\n        members: group.members.filter(m => m.id !== memberId)\n      })).filter(group => group.members.length > 0);\n      if (groupId) {\n        const targetGroup = newGroups.find(g => g.id === groupId);\n        const updatedMember = members.find(m => m.id === memberId);\n        if (targetGroup && updatedMember) {\n          targetGroup.members.push({\n            ...updatedMember,\n            groupId\n          });\n\n          // Recalculate group stats\n          const groupStats = calculateGroupStats(targetGroup);\n          targetGroup.averageExperience = groupStats.averageExperience;\n          targetGroup.dominantPriceTier = groupStats.dominantPriceTier;\n          targetGroup.categories = groupStats.categories;\n          targetGroup.lastActivity = new Date().toISOString().split('T')[0];\n        } else if (updatedMember) {\n          // Create new group\n          const groupNumber = groupId.replace('group_', '');\n          const newGroup = {\n            id: groupId,\n            name: `Group ${groupNumber}`,\n            members: [{\n              ...updatedMember,\n              groupId\n            }],\n            averageExperience: 0,\n            dominantPriceTier: '',\n            categories: [],\n            createdDate: new Date().toISOString().split('T')[0],\n            lastActivity: new Date().toISOString().split('T')[0]\n          };\n          const groupStats = calculateGroupStats(newGroup);\n          newGroup.averageExperience = groupStats.averageExperience;\n          newGroup.dominantPriceTier = groupStats.dominantPriceTier;\n          newGroup.categories = groupStats.categories;\n          newGroups.push(newGroup);\n        }\n      }\n      return newGroups;\n    });\n  };\n  const createNewGroup = memberIds => {\n    const newGroupId = `group_${Date.now()}`;\n    const groupMembers = members.filter(m => memberIds.includes(m.id));\n    const newGroup = {\n      id: newGroupId,\n      name: `Group ${groups.length + 1}`,\n      members: groupMembers.map(m => ({\n        ...m,\n        groupId: newGroupId\n      })),\n      averageExperience: 0,\n      dominantPriceTier: '',\n      categories: [],\n      createdDate: new Date().toISOString().split('T')[0],\n      lastActivity: new Date().toISOString().split('T')[0]\n    };\n\n    // Calculate group stats\n    const groupStats = calculateGroupStats(newGroup);\n    newGroup.averageExperience = groupStats.averageExperience;\n    newGroup.dominantPriceTier = groupStats.dominantPriceTier;\n    newGroup.categories = groupStats.categories;\n    setGroups(prev => [...prev, newGroup]);\n\n    // Update member group assignments\n    memberIds.forEach(memberId => {\n      updateMemberGroup(memberId, newGroupId);\n    });\n    return newGroup;\n  };\n  const getSuggestionsForMember = member => {\n    return generateGroupSuggestions(member, groups);\n  };\n  const addMemberToGroup = (memberId, groupId) => {\n    updateMemberGroup(memberId, groupId);\n  };\n  const removeMemberFromGroup = memberId => {\n    updateMemberGroup(memberId, undefined);\n  };\n  const deleteGroup = groupId => {\n    // Remove group\n    setGroups(prev => prev.filter(g => g.id !== groupId));\n\n    // Remove group assignment from members\n    setMembers(prev => prev.map(member => member.groupId === groupId ? {\n      ...member,\n      groupId: undefined\n    } : member));\n  };\n\n  // Derived data\n  const ungroupedMembers = members.filter(member => !member.groupId);\n  return {\n    members,\n    groups,\n    ungroupedMembers,\n    loading,\n    error,\n    getSuggestionsForMember,\n    addMemberToGroup,\n    removeMemberFromGroup,\n    createNewGroup,\n    deleteGroup,\n    refreshData: loadCSVData\n  };\n}\n_s(useMembers, \"7ntUB9fVrWqgv3Mvd5LrSfaxJYU=\");","map":{"version":3,"names":["useState","useEffect","generateGroupSuggestions","calculateGroupStats","parseCSVToMembers","useMembers","_s","members","setMembers","groups","setGroups","loading","setLoading","error","setError","loadCSVData","response","fetch","ok","Error","csvText","text","parsedMembers","console","log","length","groupMap","Map","forEach","member","groupId","has","set","get","push","createdGroups","groupNumber","replace","groupStats","id","name","averageExperience","dominantPriceTier","categories","createdDate","lastActivity","Date","toISOString","split","err","message","email","experience","priceTier","joinedDate","lastActive","updateMemberGroup","memberId","prevMembers","map","prevGroups","newGroups","group","filter","m","targetGroup","find","g","updatedMember","newGroup","createNewGroup","memberIds","newGroupId","now","groupMembers","includes","prev","getSuggestionsForMember","addMemberToGroup","removeMemberFromGroup","undefined","deleteGroup","ungroupedMembers","refreshData"],"sources":["/Users/mstiverson/Cursor/freeda_internal_match/src/hooks/useMembers.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { Member, Group, GroupSuggestion } from '../types';\nimport { generateGroupSuggestions, calculateGroupStats } from '../utils/matching';\nimport { parseCSVToMembers } from '../utils/csvParser';\n\nexport function useMembers() {\n  const [members, setMembers] = useState<Member[]>([]);\n  const [groups, setGroups] = useState<Group[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load real CSV data\n  useEffect(() => {\n    loadCSVData();\n  }, []);\n\n  const loadCSVData = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // Load the CSV file\n      const response = await fetch('/HS_Import spreadsheet - Members.csv');\n      if (!response.ok) {\n        throw new Error('Failed to load CSV file');\n      }\n      \n      const csvText = await response.text();\n      const parsedMembers = parseCSVToMembers(csvText);\n      \n      console.log(`Loaded ${parsedMembers.length} members from CSV`);\n      \n      // Set members\n      setMembers(parsedMembers);\n      \n      // Create groups from existing group assignments\n      const groupMap = new Map<string, Member[]>();\n      \n      parsedMembers.forEach(member => {\n        if (member.groupId) {\n          if (!groupMap.has(member.groupId)) {\n            groupMap.set(member.groupId, []);\n          }\n          groupMap.get(member.groupId)!.push(member);\n        }\n      });\n      \n      // Convert to Group objects with proper stats\n      const createdGroups: Group[] = [];\n      groupMap.forEach((members, groupId) => {\n        const groupNumber = groupId.replace('group_', '');\n        const groupStats = calculateGroupStats({\n          id: groupId,\n          name: `Group ${groupNumber}`,\n          members: members,\n          averageExperience: 0,\n          dominantPriceTier: '',\n          categories: [],\n          createdDate: '2024-01-01',\n          lastActivity: new Date().toISOString().split('T')[0]\n        });\n        \n        createdGroups.push({\n          id: groupId,\n          name: `Group ${groupNumber}`,\n          members: members,\n          averageExperience: groupStats.averageExperience,\n          dominantPriceTier: groupStats.dominantPriceTier,\n          categories: groupStats.categories,\n          createdDate: '2024-01-01',\n          lastActivity: new Date().toISOString().split('T')[0]\n        });\n      });\n      \n      setGroups(createdGroups);\n      \n    } catch (err) {\n      console.error('Error loading CSV data:', err);\n      setError(err instanceof Error ? err.message : 'Failed to load member data');\n      \n      // Fallback to a minimal mock dataset if CSV fails\n      setMembers([\n        {\n          id: 'fallback_1',\n          name: 'CSV Loading Failed',\n          email: 'error@example.com',\n          experience: 'Intermediate',\n          priceTier: 'Mid-Range',\n          categories: ['Other'],\n          joinedDate: '2024-01-01',\n          lastActive: '2024-01-01'\n        }\n      ]);\n      setGroups([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const updateMemberGroup = (memberId: string, groupId: string | undefined) => {\n    setMembers(prevMembers => \n      prevMembers.map(member => \n        member.id === memberId ? { ...member, groupId } : member\n      )\n    );\n\n    // Update groups\n    setGroups(prevGroups => {\n      const newGroups = prevGroups.map(group => ({\n        ...group,\n        members: group.members.filter(m => m.id !== memberId)\n      })).filter(group => group.members.length > 0);\n\n      if (groupId) {\n        const targetGroup = newGroups.find(g => g.id === groupId);\n        const updatedMember = members.find(m => m.id === memberId);\n        \n        if (targetGroup && updatedMember) {\n          targetGroup.members.push({ ...updatedMember, groupId });\n          \n          // Recalculate group stats\n          const groupStats = calculateGroupStats(targetGroup);\n          targetGroup.averageExperience = groupStats.averageExperience;\n          targetGroup.dominantPriceTier = groupStats.dominantPriceTier;\n          targetGroup.categories = groupStats.categories;\n          targetGroup.lastActivity = new Date().toISOString().split('T')[0];\n          \n        } else if (updatedMember) {\n          // Create new group\n          const groupNumber = groupId.replace('group_', '');\n                     const newGroup = {\n             id: groupId,\n             name: `Group ${groupNumber}`,\n             members: [{ ...updatedMember, groupId }],\n             averageExperience: 0,\n             dominantPriceTier: '',\n             categories: [] as string[],\n             createdDate: new Date().toISOString().split('T')[0],\n             lastActivity: new Date().toISOString().split('T')[0]\n           };\n          \n          const groupStats = calculateGroupStats(newGroup);\n          newGroup.averageExperience = groupStats.averageExperience;\n          newGroup.dominantPriceTier = groupStats.dominantPriceTier;\n          newGroup.categories = groupStats.categories;\n          \n          newGroups.push(newGroup);\n        }\n      }\n\n      return newGroups;\n    });\n  };\n\n  const createNewGroup = (memberIds: string[]): Group => {\n    const newGroupId = `group_${Date.now()}`;\n    const groupMembers = members.filter(m => memberIds.includes(m.id));\n    \n    const newGroup: Group = {\n      id: newGroupId,\n      name: `Group ${groups.length + 1}`,\n      members: groupMembers.map(m => ({ ...m, groupId: newGroupId })),\n      averageExperience: 0,\n      dominantPriceTier: '',\n      categories: [],\n      createdDate: new Date().toISOString().split('T')[0],\n      lastActivity: new Date().toISOString().split('T')[0]\n    };\n\n    // Calculate group stats\n    const groupStats = calculateGroupStats(newGroup);\n    newGroup.averageExperience = groupStats.averageExperience;\n    newGroup.dominantPriceTier = groupStats.dominantPriceTier;\n    newGroup.categories = groupStats.categories;\n\n    setGroups(prev => [...prev, newGroup]);\n    \n    // Update member group assignments\n    memberIds.forEach(memberId => {\n      updateMemberGroup(memberId, newGroupId);\n    });\n\n    return newGroup;\n  };\n\n  const getSuggestionsForMember = (member: Member): GroupSuggestion[] => {\n    return generateGroupSuggestions(member, groups);\n  };\n\n  const addMemberToGroup = (memberId: string, groupId: string) => {\n    updateMemberGroup(memberId, groupId);\n  };\n\n  const removeMemberFromGroup = (memberId: string) => {\n    updateMemberGroup(memberId, undefined);\n  };\n\n  const deleteGroup = (groupId: string) => {\n    // Remove group\n    setGroups(prev => prev.filter(g => g.id !== groupId));\n    \n    // Remove group assignment from members\n    setMembers(prev => \n      prev.map(member => \n        member.groupId === groupId ? { ...member, groupId: undefined } : member\n      )\n    );\n  };\n\n  // Derived data\n  const ungroupedMembers = members.filter(member => !member.groupId);\n\n  return {\n    members,\n    groups,\n    ungroupedMembers,\n    loading,\n    error,\n    getSuggestionsForMember,\n    addMemberToGroup,\n    removeMemberFromGroup,\n    createNewGroup,\n    deleteGroup,\n    refreshData: loadCSVData\n  };\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}