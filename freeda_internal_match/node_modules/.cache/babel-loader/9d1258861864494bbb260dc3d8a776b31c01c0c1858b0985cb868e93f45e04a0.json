{"ast":null,"code":"// Enhanced matching algorithm based on business strategy\nexport function calculateGroupFit(member, group) {\n  if (group.members.length === 0) return 0;\n  let score = 0;\n  let dealBreakers = 0;\n\n  // DEAL BREAKER #1: Same Industry Category (prevents direct competition)\n  const sameIndustryMembers = group.members.filter(m => m.categories.some(cat => member.categories.includes(cat)));\n  if (sameIndustryMembers.length > 0) {\n    dealBreakers += 50; // Heavy penalty for same industry\n  }\n\n  // DEAL BREAKER #2: Same Geographic Market (prevents local competition)\n  const memberLocation = extractLocation(member.location || '');\n  const sameLocationMembers = group.members.filter(m => {\n    const memberLoc = extractLocation(m.location || '');\n    return isSameMetroArea(memberLocation, memberLoc);\n  });\n  if (sameLocationMembers.length > 0) {\n    dealBreakers += 40; // Heavy penalty for same location\n  }\n\n  // PRIMARY FACTOR #1: Years Within Industry (±2 years compatibility) - 30%\n  const memberYears = member.yearsInIndustry || 0;\n  const groupYears = group.members.map(m => m.yearsInIndustry || 0);\n  const avgGroupYears = groupYears.reduce((a, b) => a + b, 0) / groupYears.length;\n  const yearsDiff = Math.abs(memberYears - avgGroupYears);\n  let yearsScore = 0;\n  if (yearsDiff <= 2) yearsScore = 100;else if (yearsDiff <= 4) yearsScore = 75;else if (yearsDiff <= 6) yearsScore = 50;else yearsScore = 25;\n  score += yearsScore * 0.3;\n\n  // PRIMARY FACTOR #2: Average Revenue Per Booking (±25% compatibility) - 30%\n  const memberRevenue = parseRevenue(member.averageRevenue);\n  const groupRevenues = group.members.map(m => parseRevenue(m.averageRevenue)).filter(r => r > 0);\n  if (groupRevenues.length > 0 && memberRevenue > 0) {\n    const avgGroupRevenue = groupRevenues.reduce((a, b) => a + b, 0) / groupRevenues.length;\n    const revenueDiff = Math.abs(memberRevenue - avgGroupRevenue) / avgGroupRevenue;\n    let revenueScore = 0;\n    if (revenueDiff <= 0.25) revenueScore = 100;else if (revenueDiff <= 0.5) revenueScore = 75;else if (revenueDiff <= 0.75) revenueScore = 50;else revenueScore = 25;\n    score += revenueScore * 0.3;\n  }\n\n  // PRIMARY FACTOR #3: Business Maturity (company founding date) - 20%\n  const memberFounded = new Date(member.companyFounded || Date.now()).getFullYear();\n  const currentYear = new Date().getFullYear();\n  const memberBusinessAge = currentYear - memberFounded;\n  const groupBusinessAges = group.members.map(m => {\n    const founded = new Date(m.companyFounded || Date.now()).getFullYear();\n    return currentYear - founded;\n  });\n  const avgGroupBusinessAge = groupBusinessAges.reduce((a, b) => a + b, 0) / groupBusinessAges.length;\n  const businessAgeDiff = Math.abs(memberBusinessAge - avgGroupBusinessAge);\n  let businessAgeScore = 0;\n  if (businessAgeDiff <= 3) businessAgeScore = 100;else if (businessAgeDiff <= 6) businessAgeScore = 75;else if (businessAgeDiff <= 10) businessAgeScore = 50;else businessAgeScore = 25;\n  score += businessAgeScore * 0.2;\n\n  // SECONDARY FACTOR: Group size optimization - 10%\n  const sizeScore = group.members.length <= 6 ? 100 : Math.max(0, 100 - (group.members.length - 6) * 10);\n  score += sizeScore * 0.1;\n\n  // SECONDARY FACTOR: Annual Revenue Scale (backup/validation) - 10%\n  const memberAnnualRevenue = parseAnnualRevenue(member.annualRevenue);\n  const groupAnnualRevenues = group.members.map(m => parseAnnualRevenue(m.annualRevenue)).filter(r => r > 0);\n  if (groupAnnualRevenues.length > 0 && memberAnnualRevenue > 0) {\n    const avgGroupAnnualRevenue = groupAnnualRevenues.reduce((a, b) => a + b, 0) / groupAnnualRevenues.length;\n    const annualRevenueDiff = Math.abs(memberAnnualRevenue - avgGroupAnnualRevenue) / avgGroupAnnualRevenue;\n    let annualRevenueScore = 0;\n    if (annualRevenueDiff <= 0.5) annualRevenueScore = 100;else if (annualRevenueDiff <= 1.0) annualRevenueScore = 75;else annualRevenueScore = 50;\n    score += annualRevenueScore * 0.1;\n  }\n\n  // Apply deal breaker penalties\n  score = Math.max(0, score - dealBreakers);\n  return Math.round(score);\n}\n\n// Generate group suggestions with new logic\nexport function generateGroupSuggestions(member, groups) {\n  const suggestions = groups.filter(group => group.members.length > 0).map(group => {\n    const score = calculateGroupFit(member, group);\n    const reasons = [];\n    const potentialIssues = [];\n\n    // Check for deal breakers\n    const sameIndustryMembers = group.members.filter(m => m.categories.some(cat => member.categories.includes(cat)));\n    if (sameIndustryMembers.length > 0) {\n      potentialIssues.push(`Same industry: ${sameIndustryMembers.map(m => m.name).join(', ')}`);\n    }\n    const memberLocation = extractLocation(member.location || '');\n    const sameLocationMembers = group.members.filter(m => {\n      const memberLoc = extractLocation(m.location || '');\n      return isSameMetroArea(memberLocation, memberLoc);\n    });\n    if (sameLocationMembers.length > 0) {\n      potentialIssues.push(`Same market: ${sameLocationMembers.map(m => m.name).join(', ')}`);\n    }\n\n    // Positive matching factors\n    const memberYears = member.yearsInIndustry || 0;\n    const groupYears = group.members.map(m => m.yearsInIndustry || 0);\n    const avgGroupYears = groupYears.reduce((a, b) => a + b, 0) / groupYears.length;\n    const yearsDiff = Math.abs(memberYears - avgGroupYears);\n    if (yearsDiff <= 2) {\n      reasons.push(`Similar experience level (${memberYears} vs ${Math.round(avgGroupYears)} years)`);\n    }\n    const memberRevenue = parseRevenue(member.averageRevenue);\n    const groupRevenues = group.members.map(m => parseRevenue(m.averageRevenue)).filter(r => r > 0);\n    if (groupRevenues.length > 0 && memberRevenue > 0) {\n      const avgGroupRevenue = groupRevenues.reduce((a, b) => a + b, 0) / groupRevenues.length;\n      const revenueDiff = Math.abs(memberRevenue - avgGroupRevenue) / avgGroupRevenue;\n      if (revenueDiff <= 0.25) {\n        reasons.push(`Similar pricing tier ($${formatRevenue(memberRevenue)} vs $${formatRevenue(avgGroupRevenue)} avg)`);\n      }\n    }\n\n    // Cross-industry learning opportunity\n    const uniqueIndustries = group.members.flatMap(m => m.categories).filter((cat, index, arr) => arr.indexOf(cat) === index).filter(cat => !member.categories.includes(cat));\n    if (uniqueIndustries.length > 0) {\n      reasons.push(`Cross-industry learning: ${uniqueIndustries.slice(0, 2).join(', ')}`);\n    }\n    return {\n      groupId: group.id,\n      groupName: group.name,\n      score,\n      reasons,\n      potentialIssues: potentialIssues.length > 0 ? potentialIssues : undefined\n    };\n  }).sort((a, b) => b.score - a.score).slice(0, 3);\n  return suggestions;\n}\n\n// Helper functions for new matching logic\nfunction extractLocation(location) {\n  // Clean up location string and extract city/state\n  const cleaned = location.replace(/['\"]/g, '').trim();\n\n  // Handle various formats: \"City, State\", \"City State\", etc.\n  const parts = cleaned.split(',').map(p => p.trim());\n  if (parts.length >= 2) {\n    return {\n      city: parts[0].toLowerCase(),\n      state: parts[1].toLowerCase(),\n      region: getRegion(parts[1].toLowerCase())\n    };\n  }\n  return {\n    city: cleaned.toLowerCase(),\n    state: '',\n    region: getRegion(cleaned.toLowerCase())\n  };\n}\nfunction isSameMetroArea(loc1, loc2) {\n  if (!loc1.city || !loc2.city) return false;\n\n  // Same city\n  if (loc1.city === loc2.city) return true;\n\n  // Major metro areas\n  const metroAreas = [['new york', 'brooklyn', 'manhattan', 'queens', 'bronx', 'staten island', 'jersey city', 'hoboken'], ['los angeles', 'hollywood', 'beverly hills', 'santa monica', 'manhattan beach', 'pasadena'], ['chicago', 'evanston', 'oak park', 'schaumburg'], ['boston', 'cambridge', 'somerville', 'newton', 'brookline'], ['san francisco', 'oakland', 'berkeley', 'palo alto', 'san jose'], ['dallas', 'fort worth', 'plano', 'frisco', 'irving'], ['miami', 'fort lauderdale', 'boca raton', 'coral gables']];\n  for (const metro of metroAreas) {\n    if (metro.includes(loc1.city) && metro.includes(loc2.city)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getRegion(location) {\n  const eastCoast = ['new york', 'ny', 'massachusetts', 'ma', 'connecticut', 'ct', 'new jersey', 'nj', 'pennsylvania', 'pa'];\n  const westCoast = ['california', 'ca', 'oregon', 'or', 'washington', 'wa'];\n  const south = ['florida', 'fl', 'texas', 'tx', 'north carolina', 'nc', 'south carolina', 'sc', 'georgia', 'ga'];\n  const midwest = ['illinois', 'il', 'michigan', 'mi', 'ohio', 'oh', 'wisconsin', 'wi', 'minnesota', 'mn'];\n  const loc = location.toLowerCase();\n  if (eastCoast.some(state => loc.includes(state))) return 'east';\n  if (westCoast.some(state => loc.includes(state))) return 'west';\n  if (south.some(state => loc.includes(state))) return 'south';\n  if (midwest.some(state => loc.includes(state))) return 'midwest';\n  return 'other';\n}\nfunction parseRevenue(revenueStr) {\n  if (!revenueStr) return 0;\n\n  // Remove currency symbols and commas\n  const cleaned = revenueStr.replace(/[\\$,]/g, '');\n  const num = parseFloat(cleaned);\n  return isNaN(num) ? 0 : num;\n}\nfunction parseAnnualRevenue(revenueRange) {\n  if (!revenueRange) return 0;\n  const ranges = {\n    '$200K and below': 150000,\n    '$200-300K': 250000,\n    '$300-400K': 350000,\n    '$400-500K': 450000,\n    '$500-600K': 550000,\n    '$600-700K': 650000,\n    '$700-800K': 750000,\n    '$800-900K': 850000,\n    '$900K-1M': 950000,\n    '$1-1.5M': 1250000,\n    '$1.5-2M': 1750000,\n    '$2-3M': 2500000,\n    '$3-4M': 3500000,\n    '$4-5M': 4500000,\n    '$5M+': 6000000\n  };\n  return ranges[revenueRange] || 0;\n}\nfunction formatRevenue(revenue) {\n  if (revenue >= 1000000) {\n    return `${(revenue / 1000000).toFixed(1)}M`;\n  } else if (revenue >= 1000) {\n    return `${(revenue / 1000).toFixed(0)}K`;\n  }\n  return revenue.toString();\n}\n\n// Keep existing functions for compatibility\nexport function analyzeGroupAlerts(groups) {\n  const alerts = [];\n  groups.forEach(group => {\n    if (group.members.length < 2) return;\n\n    // Alert for same industry members (now a major issue)\n    const industryMap = {};\n    group.members.forEach(member => {\n      member.categories.forEach(cat => {\n        if (!industryMap[cat]) industryMap[cat] = [];\n        industryMap[cat].push(member.name);\n      });\n    });\n    Object.entries(industryMap).forEach(([industry, members]) => {\n      if (members.length > 1) {\n        alerts.push({\n          groupId: group.id,\n          groupName: group.name,\n          type: 'experience_mismatch',\n          // Reusing existing type\n          severity: 'high',\n          description: `Direct competitors in ${industry}: ${members.join(', ')}`,\n          affectedMembers: members\n        });\n      }\n    });\n\n    // Alert for same location members\n    const locationMap = {};\n    group.members.forEach(member => {\n      const location = extractLocation(member.location || '');\n      const key = `${location.city}, ${location.state}`;\n      if (!locationMap[key]) locationMap[key] = [];\n      locationMap[key].push(member.name);\n    });\n    Object.entries(locationMap).forEach(([location, members]) => {\n      if (members.length > 1) {\n        alerts.push({\n          groupId: group.id,\n          groupName: group.name,\n          type: 'price_mismatch',\n          // Reusing existing type\n          severity: 'medium',\n          description: `Same market area (${location}): ${members.join(', ')}`,\n          affectedMembers: members\n        });\n      }\n    });\n  });\n  return alerts.sort((a, b) => {\n    const severityOrder = {\n      high: 3,\n      medium: 2,\n      low: 1\n    };\n    return severityOrder[b.severity] - severityOrder[a.severity];\n  });\n}\n\n// Update group statistics calculation\nexport function calculateGroupStats(group) {\n  if (group.members.length === 0) {\n    return {\n      averageExperience: 0,\n      dominantPriceTier: '',\n      categories: []\n    };\n  }\n\n  // Calculate average years in industry\n  const avgExp = group.members.reduce((sum, member) => {\n    return sum + (member.yearsInIndustry || 0);\n  }, 0) / group.members.length;\n\n  // Find dominant revenue tier\n  const revenueTiers = group.members.map(m => m.annualRevenue || 'Unknown');\n  const tierCounts = revenueTiers.reduce((acc, tier) => {\n    acc[tier] = (acc[tier] || 0) + 1;\n    return acc;\n  }, {});\n  const dominantPriceTier = Object.entries(tierCounts).sort(([, a], [, b]) => b - a)[0][0];\n\n  // Collect unique categories\n  const allCats = group.members.flatMap(m => m.categories);\n  const categories = allCats.filter((cat, index) => allCats.indexOf(cat) === index);\n  return {\n    averageExperience: Math.round(avgExp * 100) / 100,\n    dominantPriceTier,\n    categories\n  };\n}\n\n// Helper function to get experience label from score\nfunction getExperienceLabel(score) {\n  const rounded = Math.round(score);\n  switch (rounded) {\n    case 1:\n      return 'Beginner';\n    case 2:\n      return 'Intermediate';\n    case 3:\n      return 'Advanced';\n    case 4:\n      return 'Expert';\n    default:\n      return 'Unknown';\n  }\n}\n\n// Validate member data\nexport function validateMemberData(member) {\n  var _member$name, _member$email, _member$location;\n  const errors = [];\n  if (!((_member$name = member.name) !== null && _member$name !== void 0 && _member$name.trim())) {\n    errors.push('Name is required');\n  }\n  if (!((_member$email = member.email) !== null && _member$email !== void 0 && _member$email.trim())) {\n    errors.push('Email is required');\n  } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(member.email)) {\n    errors.push('Invalid email format');\n  }\n  if (!member.yearsInIndustry || member.yearsInIndustry < 0) {\n    errors.push('Years in industry is required');\n  }\n  if (!member.categories || member.categories.length === 0) {\n    errors.push('At least one category is required');\n  }\n  if (!((_member$location = member.location) !== null && _member$location !== void 0 && _member$location.trim())) {\n    errors.push('Location is required');\n  }\n  return errors;\n}","map":{"version":3,"names":["calculateGroupFit","member","group","members","length","score","dealBreakers","sameIndustryMembers","filter","m","categories","some","cat","includes","memberLocation","extractLocation","location","sameLocationMembers","memberLoc","isSameMetroArea","memberYears","yearsInIndustry","groupYears","map","avgGroupYears","reduce","a","b","yearsDiff","Math","abs","yearsScore","memberRevenue","parseRevenue","averageRevenue","groupRevenues","r","avgGroupRevenue","revenueDiff","revenueScore","memberFounded","Date","companyFounded","now","getFullYear","currentYear","memberBusinessAge","groupBusinessAges","founded","avgGroupBusinessAge","businessAgeDiff","businessAgeScore","sizeScore","max","memberAnnualRevenue","parseAnnualRevenue","annualRevenue","groupAnnualRevenues","avgGroupAnnualRevenue","annualRevenueDiff","annualRevenueScore","round","generateGroupSuggestions","groups","suggestions","reasons","potentialIssues","push","name","join","formatRevenue","uniqueIndustries","flatMap","index","arr","indexOf","slice","groupId","id","groupName","undefined","sort","cleaned","replace","trim","parts","split","p","city","toLowerCase","state","region","getRegion","loc1","loc2","metroAreas","metro","eastCoast","westCoast","south","midwest","loc","revenueStr","num","parseFloat","isNaN","revenueRange","ranges","revenue","toFixed","toString","analyzeGroupAlerts","alerts","forEach","industryMap","Object","entries","industry","type","severity","description","affectedMembers","locationMap","key","severityOrder","high","medium","low","calculateGroupStats","averageExperience","dominantPriceTier","avgExp","sum","revenueTiers","tierCounts","acc","tier","allCats","getExperienceLabel","rounded","validateMemberData","_member$name","_member$email","_member$location","errors","email","test"],"sources":["/Users/mstiverson/Cursor/freeda_internal_match/src/utils/matching.ts"],"sourcesContent":["import { Member, Group, GroupSuggestion, GroupAlert, EXPERIENCE_SCORES } from '../types';\n\n// Enhanced matching algorithm based on business strategy\nexport function calculateGroupFit(member: Member, group: Group): number {\n  if (group.members.length === 0) return 0;\n\n  let score = 0;\n  let dealBreakers = 0;\n\n  // DEAL BREAKER #1: Same Industry Category (prevents direct competition)\n  const sameIndustryMembers = group.members.filter(m => \n    m.categories.some(cat => member.categories.includes(cat))\n  );\n  if (sameIndustryMembers.length > 0) {\n    dealBreakers += 50; // Heavy penalty for same industry\n  }\n\n  // DEAL BREAKER #2: Same Geographic Market (prevents local competition)\n  const memberLocation = extractLocation(member.location || '');\n  const sameLocationMembers = group.members.filter(m => {\n    const memberLoc = extractLocation(m.location || '');\n    return isSameMetroArea(memberLocation, memberLoc);\n  });\n  if (sameLocationMembers.length > 0) {\n    dealBreakers += 40; // Heavy penalty for same location\n  }\n\n  // PRIMARY FACTOR #1: Years Within Industry (±2 years compatibility) - 30%\n  const memberYears = member.yearsInIndustry || 0;\n  const groupYears = group.members.map(m => m.yearsInIndustry || 0);\n  const avgGroupYears = groupYears.reduce((a, b) => a + b, 0) / groupYears.length;\n  const yearsDiff = Math.abs(memberYears - avgGroupYears);\n  \n  let yearsScore = 0;\n  if (yearsDiff <= 2) yearsScore = 100;\n  else if (yearsDiff <= 4) yearsScore = 75;\n  else if (yearsDiff <= 6) yearsScore = 50;\n  else yearsScore = 25;\n  \n  score += yearsScore * 0.3;\n\n  // PRIMARY FACTOR #2: Average Revenue Per Booking (±25% compatibility) - 30%\n  const memberRevenue = parseRevenue(member.averageRevenue);\n  const groupRevenues = group.members\n    .map(m => parseRevenue(m.averageRevenue))\n    .filter(r => r > 0);\n  \n  if (groupRevenues.length > 0 && memberRevenue > 0) {\n    const avgGroupRevenue = groupRevenues.reduce((a, b) => a + b, 0) / groupRevenues.length;\n    const revenueDiff = Math.abs(memberRevenue - avgGroupRevenue) / avgGroupRevenue;\n    \n    let revenueScore = 0;\n    if (revenueDiff <= 0.25) revenueScore = 100;\n    else if (revenueDiff <= 0.5) revenueScore = 75;\n    else if (revenueDiff <= 0.75) revenueScore = 50;\n    else revenueScore = 25;\n    \n    score += revenueScore * 0.3;\n  }\n\n  // PRIMARY FACTOR #3: Business Maturity (company founding date) - 20%\n  const memberFounded = new Date(member.companyFounded || Date.now()).getFullYear();\n  const currentYear = new Date().getFullYear();\n  const memberBusinessAge = currentYear - memberFounded;\n  \n  const groupBusinessAges = group.members.map(m => {\n    const founded = new Date(m.companyFounded || Date.now()).getFullYear();\n    return currentYear - founded;\n  });\n  const avgGroupBusinessAge = groupBusinessAges.reduce((a, b) => a + b, 0) / groupBusinessAges.length;\n  const businessAgeDiff = Math.abs(memberBusinessAge - avgGroupBusinessAge);\n  \n  let businessAgeScore = 0;\n  if (businessAgeDiff <= 3) businessAgeScore = 100;\n  else if (businessAgeDiff <= 6) businessAgeScore = 75;\n  else if (businessAgeDiff <= 10) businessAgeScore = 50;\n  else businessAgeScore = 25;\n  \n  score += businessAgeScore * 0.2;\n\n  // SECONDARY FACTOR: Group size optimization - 10%\n  const sizeScore = group.members.length <= 6 ? 100 : Math.max(0, 100 - (group.members.length - 6) * 10);\n  score += sizeScore * 0.1;\n\n  // SECONDARY FACTOR: Annual Revenue Scale (backup/validation) - 10%\n  const memberAnnualRevenue = parseAnnualRevenue(member.annualRevenue);\n  const groupAnnualRevenues = group.members\n    .map(m => parseAnnualRevenue(m.annualRevenue))\n    .filter(r => r > 0);\n    \n  if (groupAnnualRevenues.length > 0 && memberAnnualRevenue > 0) {\n    const avgGroupAnnualRevenue = groupAnnualRevenues.reduce((a, b) => a + b, 0) / groupAnnualRevenues.length;\n    const annualRevenueDiff = Math.abs(memberAnnualRevenue - avgGroupAnnualRevenue) / avgGroupAnnualRevenue;\n    \n    let annualRevenueScore = 0;\n    if (annualRevenueDiff <= 0.5) annualRevenueScore = 100;\n    else if (annualRevenueDiff <= 1.0) annualRevenueScore = 75;\n    else annualRevenueScore = 50;\n    \n    score += annualRevenueScore * 0.1;\n  }\n\n  // Apply deal breaker penalties\n  score = Math.max(0, score - dealBreakers);\n\n  return Math.round(score);\n}\n\n// Generate group suggestions with new logic\nexport function generateGroupSuggestions(member: Member, groups: Group[]): GroupSuggestion[] {\n  const suggestions = groups\n    .filter(group => group.members.length > 0)\n    .map(group => {\n      const score = calculateGroupFit(member, group);\n      const reasons: string[] = [];\n      const potentialIssues: string[] = [];\n\n      // Check for deal breakers\n      const sameIndustryMembers = group.members.filter(m => \n        m.categories.some(cat => member.categories.includes(cat))\n      );\n      if (sameIndustryMembers.length > 0) {\n        potentialIssues.push(`Same industry: ${sameIndustryMembers.map(m => m.name).join(', ')}`);\n      }\n\n      const memberLocation = extractLocation(member.location || '');\n      const sameLocationMembers = group.members.filter(m => {\n        const memberLoc = extractLocation(m.location || '');\n        return isSameMetroArea(memberLocation, memberLoc);\n      });\n      if (sameLocationMembers.length > 0) {\n        potentialIssues.push(`Same market: ${sameLocationMembers.map(m => m.name).join(', ')}`);\n      }\n\n      // Positive matching factors\n      const memberYears = member.yearsInIndustry || 0;\n      const groupYears = group.members.map(m => m.yearsInIndustry || 0);\n      const avgGroupYears = groupYears.reduce((a, b) => a + b, 0) / groupYears.length;\n      const yearsDiff = Math.abs(memberYears - avgGroupYears);\n      \n      if (yearsDiff <= 2) {\n        reasons.push(`Similar experience level (${memberYears} vs ${Math.round(avgGroupYears)} years)`);\n      }\n\n      const memberRevenue = parseRevenue(member.averageRevenue);\n      const groupRevenues = group.members\n        .map(m => parseRevenue(m.averageRevenue))\n        .filter(r => r > 0);\n      \n      if (groupRevenues.length > 0 && memberRevenue > 0) {\n        const avgGroupRevenue = groupRevenues.reduce((a, b) => a + b, 0) / groupRevenues.length;\n        const revenueDiff = Math.abs(memberRevenue - avgGroupRevenue) / avgGroupRevenue;\n        \n        if (revenueDiff <= 0.25) {\n          reasons.push(`Similar pricing tier ($${formatRevenue(memberRevenue)} vs $${formatRevenue(avgGroupRevenue)} avg)`);\n        }\n      }\n\n      // Cross-industry learning opportunity\n      const uniqueIndustries = group.members\n        .flatMap(m => m.categories)\n        .filter((cat, index, arr) => arr.indexOf(cat) === index)\n        .filter(cat => !member.categories.includes(cat));\n      \n      if (uniqueIndustries.length > 0) {\n        reasons.push(`Cross-industry learning: ${uniqueIndustries.slice(0, 2).join(', ')}`);\n      }\n\n      return {\n        groupId: group.id,\n        groupName: group.name,\n        score,\n        reasons,\n        potentialIssues: potentialIssues.length > 0 ? potentialIssues : undefined\n      };\n    })\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 3);\n\n  return suggestions;\n}\n\n// Helper functions for new matching logic\nfunction extractLocation(location: string): { city: string; state: string; region: string } {\n  // Clean up location string and extract city/state\n  const cleaned = location.replace(/['\"]/g, '').trim();\n  \n  // Handle various formats: \"City, State\", \"City State\", etc.\n  const parts = cleaned.split(',').map(p => p.trim());\n  \n  if (parts.length >= 2) {\n    return {\n      city: parts[0].toLowerCase(),\n      state: parts[1].toLowerCase(),\n      region: getRegion(parts[1].toLowerCase())\n    };\n  }\n  \n  return {\n    city: cleaned.toLowerCase(),\n    state: '',\n    region: getRegion(cleaned.toLowerCase())\n  };\n}\n\nfunction isSameMetroArea(loc1: any, loc2: any): boolean {\n  if (!loc1.city || !loc2.city) return false;\n  \n  // Same city\n  if (loc1.city === loc2.city) return true;\n  \n  // Major metro areas\n  const metroAreas = [\n    ['new york', 'brooklyn', 'manhattan', 'queens', 'bronx', 'staten island', 'jersey city', 'hoboken'],\n    ['los angeles', 'hollywood', 'beverly hills', 'santa monica', 'manhattan beach', 'pasadena'],\n    ['chicago', 'evanston', 'oak park', 'schaumburg'],\n    ['boston', 'cambridge', 'somerville', 'newton', 'brookline'],\n    ['san francisco', 'oakland', 'berkeley', 'palo alto', 'san jose'],\n    ['dallas', 'fort worth', 'plano', 'frisco', 'irving'],\n    ['miami', 'fort lauderdale', 'boca raton', 'coral gables']\n  ];\n  \n  for (const metro of metroAreas) {\n    if (metro.includes(loc1.city) && metro.includes(loc2.city)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nfunction getRegion(location: string): string {\n  const eastCoast = ['new york', 'ny', 'massachusetts', 'ma', 'connecticut', 'ct', 'new jersey', 'nj', 'pennsylvania', 'pa'];\n  const westCoast = ['california', 'ca', 'oregon', 'or', 'washington', 'wa'];\n  const south = ['florida', 'fl', 'texas', 'tx', 'north carolina', 'nc', 'south carolina', 'sc', 'georgia', 'ga'];\n  const midwest = ['illinois', 'il', 'michigan', 'mi', 'ohio', 'oh', 'wisconsin', 'wi', 'minnesota', 'mn'];\n  \n  const loc = location.toLowerCase();\n  \n  if (eastCoast.some(state => loc.includes(state))) return 'east';\n  if (westCoast.some(state => loc.includes(state))) return 'west';\n  if (south.some(state => loc.includes(state))) return 'south';\n  if (midwest.some(state => loc.includes(state))) return 'midwest';\n  \n  return 'other';\n}\n\nfunction parseRevenue(revenueStr: string | undefined): number {\n  if (!revenueStr) return 0;\n  \n  // Remove currency symbols and commas\n  const cleaned = revenueStr.replace(/[\\$,]/g, '');\n  const num = parseFloat(cleaned);\n  \n  return isNaN(num) ? 0 : num;\n}\n\nfunction parseAnnualRevenue(revenueRange: string | undefined): number {\n  if (!revenueRange) return 0;\n  \n  const ranges: { [key: string]: number } = {\n    '$200K and below': 150000,\n    '$200-300K': 250000,\n    '$300-400K': 350000,\n    '$400-500K': 450000,\n    '$500-600K': 550000,\n    '$600-700K': 650000,\n    '$700-800K': 750000,\n    '$800-900K': 850000,\n    '$900K-1M': 950000,\n    '$1-1.5M': 1250000,\n    '$1.5-2M': 1750000,\n    '$2-3M': 2500000,\n    '$3-4M': 3500000,\n    '$4-5M': 4500000,\n    '$5M+': 6000000\n  };\n  \n  return ranges[revenueRange] || 0;\n}\n\nfunction formatRevenue(revenue: number): string {\n  if (revenue >= 1000000) {\n    return `${(revenue / 1000000).toFixed(1)}M`;\n  } else if (revenue >= 1000) {\n    return `${(revenue / 1000).toFixed(0)}K`;\n  }\n  return revenue.toString();\n}\n\n// Keep existing functions for compatibility\nexport function analyzeGroupAlerts(groups: Group[]): GroupAlert[] {\n  const alerts: GroupAlert[] = [];\n\n  groups.forEach(group => {\n    if (group.members.length < 2) return;\n\n    // Alert for same industry members (now a major issue)\n    const industryMap: { [key: string]: string[] } = {};\n    group.members.forEach(member => {\n      member.categories.forEach(cat => {\n        if (!industryMap[cat]) industryMap[cat] = [];\n        industryMap[cat].push(member.name);\n      });\n    });\n\n    Object.entries(industryMap).forEach(([industry, members]) => {\n      if (members.length > 1) {\n        alerts.push({\n          groupId: group.id,\n          groupName: group.name,\n          type: 'experience_mismatch', // Reusing existing type\n          severity: 'high',\n          description: `Direct competitors in ${industry}: ${members.join(', ')}`,\n          affectedMembers: members\n        });\n      }\n    });\n\n    // Alert for same location members\n    const locationMap: { [key: string]: string[] } = {};\n    group.members.forEach(member => {\n      const location = extractLocation(member.location || '');\n      const key = `${location.city}, ${location.state}`;\n      if (!locationMap[key]) locationMap[key] = [];\n      locationMap[key].push(member.name);\n    });\n\n    Object.entries(locationMap).forEach(([location, members]) => {\n      if (members.length > 1) {\n        alerts.push({\n          groupId: group.id,\n          groupName: group.name,\n          type: 'price_mismatch', // Reusing existing type\n          severity: 'medium',\n          description: `Same market area (${location}): ${members.join(', ')}`,\n          affectedMembers: members\n        });\n      }\n    });\n  });\n\n  return alerts.sort((a, b) => {\n    const severityOrder = { high: 3, medium: 2, low: 1 };\n    return severityOrder[b.severity] - severityOrder[a.severity];\n  });\n}\n\n// Update group statistics calculation\nexport function calculateGroupStats(group: Group): {\n  averageExperience: number;\n  dominantPriceTier: string;\n  categories: string[];\n} {\n  if (group.members.length === 0) {\n    return {\n      averageExperience: 0,\n      dominantPriceTier: '',\n      categories: []\n    };\n  }\n\n  // Calculate average years in industry\n  const avgExp = group.members.reduce((sum, member) => {\n    return sum + (member.yearsInIndustry || 0);\n  }, 0) / group.members.length;\n\n  // Find dominant revenue tier\n  const revenueTiers = group.members.map(m => m.annualRevenue || 'Unknown');\n  const tierCounts = revenueTiers.reduce((acc, tier) => {\n    acc[tier] = (acc[tier] || 0) + 1;\n    return acc;\n  }, {} as Record<string, number>);\n\n  const dominantPriceTier = Object.entries(tierCounts)\n    .sort(([,a], [,b]) => b - a)[0][0];\n\n  // Collect unique categories\n  const allCats = group.members.flatMap(m => m.categories);\n  const categories = allCats.filter((cat, index) => allCats.indexOf(cat) === index);\n\n  return {\n    averageExperience: Math.round(avgExp * 100) / 100,\n    dominantPriceTier,\n    categories\n  };\n}\n\n// Helper function to get experience label from score\nfunction getExperienceLabel(score: number): string {\n  const rounded = Math.round(score);\n  switch (rounded) {\n    case 1: return 'Beginner';\n    case 2: return 'Intermediate';\n    case 3: return 'Advanced';\n    case 4: return 'Expert';\n    default: return 'Unknown';\n  }\n}\n\n// Validate member data\nexport function validateMemberData(member: Partial<Member>): string[] {\n  const errors: string[] = [];\n\n  if (!member.name?.trim()) {\n    errors.push('Name is required');\n  }\n\n  if (!member.email?.trim()) {\n    errors.push('Email is required');\n  } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(member.email)) {\n    errors.push('Invalid email format');\n  }\n\n  if (!member.yearsInIndustry || member.yearsInIndustry < 0) {\n    errors.push('Years in industry is required');\n  }\n\n  if (!member.categories || member.categories.length === 0) {\n    errors.push('At least one category is required');\n  }\n\n  if (!member.location?.trim()) {\n    errors.push('Location is required');\n  }\n\n  return errors;\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}